<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>intercom_python_sdk.core.api_base API documentation</title>
<meta name="description" content="API Base Module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>intercom_python_sdk.core.api_base</code></h1>
</header>
<section id="section-intro">
<h1 id="api-base-module">API Base Module</h1>
<p><code>core/api_base.py</code></p>
<p>Contains the core base classes and methodsfor all API classes in the Intercom Python SDK.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# API Base Module

`core/api_base.py`

Contains the core base classes and methodsfor all API classes in the Intercom Python SDK.
&#34;&#34;&#34;
# Third-Party Imports
from uplink import (
    Consumer,
    json
)

# Local Imports
from .configuration import Configuration
from .model_base import ModelBase


class APIProxyInterface:
    &#34;&#34;&#34;
    A proxy class that functions as an interface to API client / consumer objects.
    This allows for interception of API calls and modification of the results.
    In practice, this is how the model instance objects are captured and injected
    with the API client object.

    Given the nature of the Uplink library, it is not possible to inject a reference
    to the API client object into the model instance objects from within the API client
    itself.

    Args:
        api_class: The API class to proxy.
        config: The configuration settings for the API.

    Attributes:
        All attributes and methods are passed through to the API object. It will be as if
        you are accessing the API object directly.

    Returns:
        A proxy class that functions as an interface to API client / consumer objects.
    &#34;&#34;&#34;
    def __init__(self, api_class, config):
        &#34;&#34;&#34;
        Set the API object for the API we are proxying

        Args:
            api_class: The API class to proxy.
            config: The configuration settings for the API.
        &#34;&#34;&#34;
        self.api_object = api_class(config)

    def __dir__(self):
        &#34;&#34;&#34; Proxy the dir() method to the API object. &#34;&#34;&#34;
        return dir(self.api_object)

    def __getattribute__(self, item):
        &#34;&#34;&#34; Proxy all attribute access to the API object (except for api_object itself). &#34;&#34;&#34;
        api_object = object.__getattribute__(self, &#39;api_object&#39;)
        if item == &#39;api_object&#39;:
            return api_object
        attr = getattr(api_object, item)
        if callable(attr):
            # This is where we wrap the callable to intercept the result
            return object.__getattribute__(self, &#39;_wrap_callable&#39;)(attr)
        else:
            return attr

    def __setattr__(self, item, value):
        &#34;&#34;&#34; Proxy all attribute setting to the API object (except for api_object itself). &#34;&#34;&#34;
        if item == &#39;api_object&#39;:
            return object.__setattr__(self, item, value)
        api_object = object.__getattribute__(self, &#39;api_object&#39;)
        setattr(api_object, item, value)

    def __call__(self, *args, **kwargs):
        raise NotImplementedError(&#34;Direct method calls on APIProxyInterface are not supported. \
                                  Access methods through api_object.&#34;)

    def __repr__(self):
        return repr(f&#34;&lt;{object.__getattribute__(self, &#39;__class__&#39;).__name__}&gt; - {self.api_object}&#34;)

    def _wrap_callable(self, method):
        &#34;&#34;&#34;
        Wraps callable method to intercept the result.
        If the result is a model object, inject the API client into the model object.
        &#34;&#34;&#34;
        def wrapped(*args, **kwargs):
            result = method(*args, **kwargs)
            inject_into_instances = object.__getattribute__(self, &#39;_inject_into_instances&#39;)
            inject_into_instances(result, ModelBase, &#39;api_client&#39;, self.api_object)
            return result
        return wrapped

    def _inject_into_instances(self, obj, cls, attribute_name, attribute_value, visited=None):
        &#34;&#34;&#34;
        Allows us to inject an attribute into all instances of a class, contained
        within an arbitrary data structure of unknown depth.

        This is useful for injecting the API client instance into Model Objects
        that may be contained within some nested data structure (like a list of objects).
        &#34;&#34;&#34;
        if visited is None:
            visited = set()

        if id(obj) in visited:
            return

        visited.add(id(obj))

        inject_into_instances_method = object.__getattribute__(self, &#39;_inject_into_instances&#39;)
        inject = lambda obj: inject_into_instances_method(obj, cls, attribute_name, attribute_value, visited) # noqa

        if isinstance(obj, cls):
            obj.__setattr__(attribute_name, attribute_value)

        if isinstance(obj, dict):
            for value in obj.values():
                inject(value)

        elif isinstance(obj, (list, set, tuple)):
            for item in obj:
                inject(item)

        elif hasattr(obj, &#39;__dict__&#39;):
            for attr in vars(obj).values():
                inject(attr)


@json
class APIBase(Consumer):
    &#34;&#34;&#34;
    The base class for all API classes in the Intercom Python SDK.
    &#34;&#34;&#34;
    URI = &#34;&#34;

    def __init__(self, config: Configuration, **kwargs):
        &#34;&#34;&#34;
        Initializes a new instance of the APIBase class.
        Overrides the Consumer class from the Uplink library to
        configure the Consumer instance using a Configuration object.

        Args:
            config: The configuration settings for the API.
        &#34;&#34;&#34;
        self.config = config

        self.base_url = config.base_url + self.URI

        super().__init__(
            base_url=self.base_url,
            converters=config.converters,
            hooks=config.hooks,
            auth=config.auth,
            client=config.session
        )

    def make_subapi(self, api_tag, api_cls, api_config):
        # api_tag is the name of the subapi
        # api_cls class
        # api_config is the config object

        if not hasattr(self, api_tag):
            # If the subapi has not been created yet, create it
            setattr(self, api_tag, create_api_client(api_cls, api_config))

        else:
            # If the subapi has already been created, return it
            return getattr(self, api_tag)


# Functions
def create_api_client(api_class: &#39;APIBase&#39;, config: Configuration) -&gt; APIProxyInterface:
    &#34;&#34;&#34;
    Creates a proxy interface for an API client for the provided API class.

    Args:
        api_class: The API class to create a client for.
        config: The configuration settings for the API.

    Returns:
        An proxy interface to the instance of the API class with an API client attached to each model object.
    &#34;&#34;&#34;
    return APIProxyInterface(api_class, config)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="intercom_python_sdk.core.api_base.create_api_client"><code class="name flex">
<span>def <span class="ident">create_api_client</span></span>(<span>api_class: <a title="intercom_python_sdk.core.api_base.APIBase" href="#intercom_python_sdk.core.api_base.APIBase">APIBase</a>, config: <a title="intercom_python_sdk.core.configuration.Configuration" href="configuration.html#intercom_python_sdk.core.configuration.Configuration">Configuration</a>) ‑> <a title="intercom_python_sdk.core.api_base.APIProxyInterface" href="#intercom_python_sdk.core.api_base.APIProxyInterface">APIProxyInterface</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a proxy interface for an API client for the provided API class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_class</code></strong></dt>
<dd>The API class to create a client for.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>The configuration settings for the API.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An proxy interface to the instance of the API class with an API client attached to each model object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_api_client(api_class: &#39;APIBase&#39;, config: Configuration) -&gt; APIProxyInterface:
    &#34;&#34;&#34;
    Creates a proxy interface for an API client for the provided API class.

    Args:
        api_class: The API class to create a client for.
        config: The configuration settings for the API.

    Returns:
        An proxy interface to the instance of the API class with an API client attached to each model object.
    &#34;&#34;&#34;
    return APIProxyInterface(api_class, config)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="intercom_python_sdk.core.api_base.APIBase"><code class="flex name class">
<span>class <span class="ident">APIBase</span></span>
<span>(</span><span>config: <a title="intercom_python_sdk.core.configuration.Configuration" href="configuration.html#intercom_python_sdk.core.configuration.Configuration">Configuration</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all API classes in the Intercom Python SDK.</p>
<p>Initializes a new instance of the APIBase class.
Overrides the Consumer class from the Uplink library to
configure the Consumer instance using a Configuration object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>The configuration settings for the API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@json
class APIBase(Consumer):
    &#34;&#34;&#34;
    The base class for all API classes in the Intercom Python SDK.
    &#34;&#34;&#34;
    URI = &#34;&#34;

    def __init__(self, config: Configuration, **kwargs):
        &#34;&#34;&#34;
        Initializes a new instance of the APIBase class.
        Overrides the Consumer class from the Uplink library to
        configure the Consumer instance using a Configuration object.

        Args:
            config: The configuration settings for the API.
        &#34;&#34;&#34;
        self.config = config

        self.base_url = config.base_url + self.URI

        super().__init__(
            base_url=self.base_url,
            converters=config.converters,
            hooks=config.hooks,
            auth=config.auth,
            client=config.session
        )

    def make_subapi(self, api_tag, api_cls, api_config):
        # api_tag is the name of the subapi
        # api_cls class
        # api_config is the config object

        if not hasattr(self, api_tag):
            # If the subapi has not been created yet, create it
            setattr(self, api_tag, create_api_client(api_cls, api_config))

        else:
            # If the subapi has already been created, return it
            return getattr(self, api_tag)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>uplink.builder.Consumer</li>
<li>uplink.interfaces.Consumer</li>
<li>uplink.builder._Consumer</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="intercom_python_sdk.apis.admins.api.AdminsAPI" href="../apis/admins/api.html#intercom_python_sdk.apis.admins.api.AdminsAPI">AdminsAPI</a></li>
<li><a title="intercom_python_sdk.apis.articles.api.ArticlesAPI" href="../apis/articles/api.html#intercom_python_sdk.apis.articles.api.ArticlesAPI">ArticlesAPI</a></li>
<li><a title="intercom_python_sdk.apis.data_attributes.api.DataAttributesAPI" href="../apis/data_attributes/api.html#intercom_python_sdk.apis.data_attributes.api.DataAttributesAPI">DataAttributesAPI</a></li>
<li><a title="intercom_python_sdk.apis.data_events.api.DataEventsAPI" href="../apis/data_events/api.html#intercom_python_sdk.apis.data_events.api.DataEventsAPI">DataEventsAPI</a></li>
<li><a title="intercom_python_sdk.apis.data_export.api.DataExportAPI" href="../apis/data_export/api.html#intercom_python_sdk.apis.data_export.api.DataExportAPI">DataExportAPI</a></li>
<li><a title="intercom_python_sdk.apis.help_center.api.HelpCenterAPI" href="../apis/help_center/api.html#intercom_python_sdk.apis.help_center.api.HelpCenterAPI">HelpCenterAPI</a></li>
<li><a title="intercom_python_sdk.apis.teams.api.TeamsAPI" href="../apis/teams/api.html#intercom_python_sdk.apis.teams.api.TeamsAPI">TeamsAPI</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="intercom_python_sdk.core.api_base.APIBase.URI"><code class="name">var <span class="ident">URI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="intercom_python_sdk.core.api_base.APIBase.make_subapi"><code class="name flex">
<span>def <span class="ident">make_subapi</span></span>(<span>self, api_tag, api_cls, api_config)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_subapi(self, api_tag, api_cls, api_config):
    # api_tag is the name of the subapi
    # api_cls class
    # api_config is the config object

    if not hasattr(self, api_tag):
        # If the subapi has not been created yet, create it
        setattr(self, api_tag, create_api_client(api_cls, api_config))

    else:
        # If the subapi has already been created, return it
        return getattr(self, api_tag)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="intercom_python_sdk.core.api_base.APIProxyInterface"><code class="flex name class">
<span>class <span class="ident">APIProxyInterface</span></span>
<span>(</span><span>api_class, config)</span>
</code></dt>
<dd>
<div class="desc"><p>A proxy class that functions as an interface to API client / consumer objects.
This allows for interception of API calls and modification of the results.
In practice, this is how the model instance objects are captured and injected
with the API client object.</p>
<p>Given the nature of the Uplink library, it is not possible to inject a reference
to the API client object into the model instance objects from within the API client
itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_class</code></strong></dt>
<dd>The API class to proxy.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>The configuration settings for the API.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<p>All attributes and methods are passed through to the API object. It will be as if
you are accessing the API object directly.</p>
<h2 id="returns">Returns</h2>
<p>A proxy class that functions as an interface to API client / consumer objects.
Set the API object for the API we are proxying</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>api_class</code></strong></dt>
<dd>The API class to proxy.</dd>
<dt><strong><code>config</code></strong></dt>
<dd>The configuration settings for the API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class APIProxyInterface:
    &#34;&#34;&#34;
    A proxy class that functions as an interface to API client / consumer objects.
    This allows for interception of API calls and modification of the results.
    In practice, this is how the model instance objects are captured and injected
    with the API client object.

    Given the nature of the Uplink library, it is not possible to inject a reference
    to the API client object into the model instance objects from within the API client
    itself.

    Args:
        api_class: The API class to proxy.
        config: The configuration settings for the API.

    Attributes:
        All attributes and methods are passed through to the API object. It will be as if
        you are accessing the API object directly.

    Returns:
        A proxy class that functions as an interface to API client / consumer objects.
    &#34;&#34;&#34;
    def __init__(self, api_class, config):
        &#34;&#34;&#34;
        Set the API object for the API we are proxying

        Args:
            api_class: The API class to proxy.
            config: The configuration settings for the API.
        &#34;&#34;&#34;
        self.api_object = api_class(config)

    def __dir__(self):
        &#34;&#34;&#34; Proxy the dir() method to the API object. &#34;&#34;&#34;
        return dir(self.api_object)

    def __getattribute__(self, item):
        &#34;&#34;&#34; Proxy all attribute access to the API object (except for api_object itself). &#34;&#34;&#34;
        api_object = object.__getattribute__(self, &#39;api_object&#39;)
        if item == &#39;api_object&#39;:
            return api_object
        attr = getattr(api_object, item)
        if callable(attr):
            # This is where we wrap the callable to intercept the result
            return object.__getattribute__(self, &#39;_wrap_callable&#39;)(attr)
        else:
            return attr

    def __setattr__(self, item, value):
        &#34;&#34;&#34; Proxy all attribute setting to the API object (except for api_object itself). &#34;&#34;&#34;
        if item == &#39;api_object&#39;:
            return object.__setattr__(self, item, value)
        api_object = object.__getattribute__(self, &#39;api_object&#39;)
        setattr(api_object, item, value)

    def __call__(self, *args, **kwargs):
        raise NotImplementedError(&#34;Direct method calls on APIProxyInterface are not supported. \
                                  Access methods through api_object.&#34;)

    def __repr__(self):
        return repr(f&#34;&lt;{object.__getattribute__(self, &#39;__class__&#39;).__name__}&gt; - {self.api_object}&#34;)

    def _wrap_callable(self, method):
        &#34;&#34;&#34;
        Wraps callable method to intercept the result.
        If the result is a model object, inject the API client into the model object.
        &#34;&#34;&#34;
        def wrapped(*args, **kwargs):
            result = method(*args, **kwargs)
            inject_into_instances = object.__getattribute__(self, &#39;_inject_into_instances&#39;)
            inject_into_instances(result, ModelBase, &#39;api_client&#39;, self.api_object)
            return result
        return wrapped

    def _inject_into_instances(self, obj, cls, attribute_name, attribute_value, visited=None):
        &#34;&#34;&#34;
        Allows us to inject an attribute into all instances of a class, contained
        within an arbitrary data structure of unknown depth.

        This is useful for injecting the API client instance into Model Objects
        that may be contained within some nested data structure (like a list of objects).
        &#34;&#34;&#34;
        if visited is None:
            visited = set()

        if id(obj) in visited:
            return

        visited.add(id(obj))

        inject_into_instances_method = object.__getattribute__(self, &#39;_inject_into_instances&#39;)
        inject = lambda obj: inject_into_instances_method(obj, cls, attribute_name, attribute_value, visited) # noqa

        if isinstance(obj, cls):
            obj.__setattr__(attribute_name, attribute_value)

        if isinstance(obj, dict):
            for value in obj.values():
                inject(value)

        elif isinstance(obj, (list, set, tuple)):
            for item in obj:
                inject(item)

        elif hasattr(obj, &#39;__dict__&#39;):
            for attr in vars(obj).values():
                inject(attr)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#api-base-module">API Base Module</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="intercom_python_sdk.core" href="index.html">intercom_python_sdk.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="intercom_python_sdk.core.api_base.create_api_client" href="#intercom_python_sdk.core.api_base.create_api_client">create_api_client</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="intercom_python_sdk.core.api_base.APIBase" href="#intercom_python_sdk.core.api_base.APIBase">APIBase</a></code></h4>
<ul class="">
<li><code><a title="intercom_python_sdk.core.api_base.APIBase.URI" href="#intercom_python_sdk.core.api_base.APIBase.URI">URI</a></code></li>
<li><code><a title="intercom_python_sdk.core.api_base.APIBase.make_subapi" href="#intercom_python_sdk.core.api_base.APIBase.make_subapi">make_subapi</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="intercom_python_sdk.core.api_base.APIProxyInterface" href="#intercom_python_sdk.core.api_base.APIProxyInterface">APIProxyInterface</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>